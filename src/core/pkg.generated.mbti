// Generated using `moon info`, DON'T EDIT IT
package "ZSeanYves/MoonbitHTTP/core"

import(
  "ZSeanYves/MoonbitHTTP/transport"
)

// Values
pub fn _hex_to_int(String) -> Result[Int, String]

pub fn _int_to_hex(Int) -> String

pub fn _skip_hdr_in_no_body(String) -> Bool

pub fn body_bytes(Array[Byte]) -> Body

pub fn body_empty() -> Body

pub fn body_len(Body) -> Int

pub fn body_stream_from_bytes(Array[Byte]) -> Body

pub fn byte_slice(Array[Byte], Int, Int) -> Array[Byte]

pub fn bytes_to_utf8(Array[Byte], String) -> Result[String, String]

pub fn content_length_opt(Map[String, String]) -> Int?

pub fn copy_first(Array[Byte], Int) -> Array[Byte]

pub fn default_reason(Int) -> String

pub fn err_io(String) -> Herror

pub fn err_proto(String) -> Herror

pub fn err_user(String) -> Herror

pub fn error_to_string(Herror) -> String

pub fn find_byte(Array[Byte], Byte) -> Int?

pub fn get_all_ci(Map[String, String], String) -> Array[String]

pub fn get_ci(Map[String, String], String) -> String?

pub fn has_token_ci(Map[String, String], String, String) -> Bool

pub fn header_get(Request, String) -> String?

pub fn ltrim_ascii(Array[Byte]) -> Array[Byte]

pub fn make_status(Int, String) -> Status

pub fn make_status_from(StatusCode) -> Status

pub fn norm_key(String) -> String

pub fn parse_chunk_size_line(String) -> Result[Int, String]

pub fn parse_content_length(Map[String, String]) -> Result[Int, String]

pub fn push_ascii(Array[Byte], String) -> Array[Byte]

pub fn req_line(Method, String, String) -> RequestLine

pub fn request_new(RequestLine, Map[String, String]) -> Request

pub fn resp_bytes(Int, String, Map[String, String], Array[Byte]) -> Response

pub fn resp_empty(Int, String, Map[String, String]) -> Response

pub fn rtrim_ascii(Array[Byte]) -> Array[Byte]

pub fn split_header_list(String, String) -> Array[String]

pub fn status(Int, String) -> Status

pub fn status_code_value(StatusCode) -> Int

pub fn status_no_body(Int) -> Bool

pub fn str_contains(String, String) -> Bool

pub fn str_slice(String, Int, Int) -> String

pub fn str_starts_with(String, String) -> Bool

pub fn trim_sp(String) -> String

pub fn write_ascii(@transport.Transport, String) -> Result[Unit, String]

// Errors
pub suberror Herror {
  Io(String)
  Proto(String)
  User(String)
}

// Types and methods
pub(all) enum Body {
  Empty
  Bytes(Array[Byte])
  Stream(() -> Result[(Array[Byte], Bool), String])
}

pub(all) struct Limits {
  max_headers : Int
  max_line : Int
  read_win : Int
  max_body : Int
}

pub(all) enum Method {
  GET
  POST
  PUT
  DELETE
  HEAD
  OPTIONS
  PATCH
  TRACE
  CONNECT
  Other(String)
}

pub(all) struct Request {
  line : RequestLine
  headers : Map[String, String]
  body : Body
}

pub(all) struct RequestLine {
  http_method : Method
  target : String
  version : String
}

pub(all) struct Response {
  status : Status
  headers : Map[String, String]
  body : Body
}

pub(all) struct Status {
  code : Int
  reason : String
}

pub(all) enum StatusCode {
  Continue
  SwitchingProtocols
  Processing
  EarlyHints
  OK
  Created
  Accepted
  NoContent
  PartialContent
  MultipleChoices
  MovedPermanently
  Found
  SeeOther
  NotModified
  TemporaryRedirect
  PermanentRedirect
  BadRequest
  Unauthorized
  Forbidden
  NotFound
  MethodNotAllowed
  RequestTimeout
  LengthRequired
  PayloadTooLarge
  URITooLong
  UnsupportedMediaType
  ExpectationFailed
  MisdirectedRequest
  UnprocessableContent
  UpgradeRequired
  TooManyRequests
  RequestHeaderFieldsTooLarge
  InternalServerError
  NotImplemented
  BadGateway
  ServiceUnavailable
  GatewayTimeout
  HTTPVersionNotSupported
}

pub(all) struct StatusLine {
  version : String
  code : Int
  reason : String
}

// Type aliases

// Traits

